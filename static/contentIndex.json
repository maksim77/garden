{"index":{"title":"index","links":["notes/Development/YandexGPT-в-Obsidian-TextGenerator","notes/Development/OpenTelemetry","notes/Development/00_GRPC","notes/Development/Thrift","notes/Development/Git-user-checks","notes/Development/Draft-actions"],"tags":[],"content":"Добро пожаловать в ещё один цифровой садик.\nПо сути это небольшой кусочек моего Obsidian доступный всем. Большинство заметок здесь я специально не готовил к публикации и они видны “как есть”, что означает местами специфическое форматирование или хвосты каких-то плагинов которые не видны в интерфейсе Quartz.\nTech &amp; Dev\n\nYandexGPT в Obsidian TextGenerator\nOpenTelemetry - мои заметки по работе с OTEL.\n00_GRPC\nThrift\n\nPets\n\nGit user checks\nDraft actions\n"},"notes/Development/00_GRPC":{"title":"00_GRPC","links":["notes/Development/00_GRPC","notes/Development/Установка-GRPC-в-Golang","notes/Development/Компиляция-proto-файла-для-Golang","notes/Development/Подключение-к-GRPC-server'у","notes/Development/Создание-перехватчика-GRPC","notes/Development/GRPC-Reflection","notes/Development/Thrift"],"tags":["reference/golang"],"content":"00_GRPC\n\nУстановка GRPC в Golang\nКомпиляция proto файла для Golang\nПодключение к GRPC server’у\nСоздание перехватчика GRPC\nGRPC Reflection\n\nFriend:: Thrift"},"notes/Development/Draft-actions":{"title":"Draft actions","links":["notes/Development/Draft-actions"],"tags":[],"content":"Draft actions\nI really like the Draft app, and I have written a number of actions for it. I wrote them for myself, but some of them seemed interesting enough for me to share with everyone.\n\nMastodon Reply - simple action that allows you to reply to Mastodon toot directly from within Draft.\nCalendar - this action takes all of today’s events from the calendar and creates a markdown for Obsidian Daily Notes.\n"},"notes/Development/GRPC-Reflection":{"title":"GRPC Reflection","links":["notes/Development/GRPC-Reflection"],"tags":["reference/golang"],"content":"GRPC Reflection\nСуществует возможность получать список методов, узнавать описания сообщений и даже вызывать методы с помощью утилиты командной строки grpc_cli.\nСборка утилиты\n\nКлонировать grpc репозиторий\ngit submodule update --init\nmkdir -p cmake/build\ncd cmake/build\ncmake -DgRPC_BUILD_TESTS=ON ../..\nmake grpc_cli\n\nНастройка севера для работы с reflection\nimport &quot;google.golang.org/grpc/reflection&quot;\n \ns := grpc.NewServer()\nreflection.Register(s)"},"notes/Development/Git-user-checks":{"title":"Git user checks","links":["notes/Development/Git-user-checks"],"tags":[],"content":"Git user checks\n\nVSCode Marketplace\nGitHub\n\nSometimes, after cloning a repository from a corporate git server and sending several commits to it, you realize that you forgot to change the user settings in git.\nThis extension was written to avoid that.\nYou only need to define three parameters. The first is the domain that the extension will look for in the origin section of the repository that you opened in VSCode.\nThe other two are user settings that need to be set for the repository cloned from the domain specified in the first paragraph.\n\nThat’s it! The extension will warn you that you are working with a repository for which user settings should be set (if they are not already set). Clicking the “Overwrite” button will automatically add the necessary parameters to the git settings of the current project.\n"},"notes/Development/OTEL-Baggage.-Golang":{"title":"OTEL Baggage. Golang","links":["notes/Development/OTEL-Baggage.-Golang"],"tags":["reference/golang"],"content":"OTEL Baggage. Golang\nb, _ := baggage.NewMember(&quot;key&quot;, &quot;value&quot;)\nbag, _ := baggage.New(b)\nctx = baggage.ContextWithBaggage(ctx, bag)\nИсходный контекст в этом примере мог быть создан например при старте нового span’а. И если потом сделать его Inject то он передастся как http заголовок:\notel.GetTextMapPropagator().Inject(ctx, propagation.HeaderCarrier(w.Header()))\nИзвлечение пришедшей таким образом информации:\nctx := otel.GetTextMapPropagator().Extract(r.Context(), propagation.HeaderCarrier(r.Header))\n \nbag := baggage.FromContext(ctx)\n_, span := tracer.Start(ctx, &quot;second&quot;)\ndefer span.End() \nfmt.Println(bag.Member(&quot;key&quot;).Value())\n\n\n                  \n                  TextMapPropogator \n                  \n                \n\nВажно при объявлении TextMapPropogator использовать следующую структуру: otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(propagation.TraceContext{}, propagation.Baggage{})).\n\n"},"notes/Development/OTEL-initialization":{"title":"OTEL initialization","links":["notes/Development/OTEL-initialization","notes/Development/Инициализация-OTEL-в-go","notes/Development/Базовая-настройка-OTEL-для-работы-с-Jaeger","notes/Development/Базовая-настройка-OTEL-для-работы-с-OTEL-Collector"],"tags":[],"content":"OTEL initialization\n\nChildren:: Инициализация OTEL в go\nChildren:: Базовая настройка OTEL для работы с Jaeger\nChildren:: Базовая настройка OTEL для работы с OTEL Collector\n"},"notes/Development/OTEL-and-Jaeger-local-dev":{"title":"OTEL&Jaeger local dev","links":["notes/Development/OTEL-and-Jaeger-local-dev"],"tags":[],"content":"OTEL&amp;Jaeger local dev\nDocker compose\nversion: &#039;3.8&#039;\n \nservices:\n  otel-collector:\n    image: otel/opentelemetry-collector:latest\n    container_name: otel-collector\n    command: [&quot;--config=/etc/otel-collector-config.yaml&quot;]\n    volumes:\n      - ./otel-collector-config.yaml:/etc/otel-collector-config.yaml\n    ports:\n      - &quot;4317:4317&quot;  # OTLP gRPC receiver\n      - &quot;4318:4318&quot;  # OTLP HTTP receiver\n      - &quot;55679:55679&quot;  # Prometheus exporter\n      - &quot;8889:8889&quot;\n    depends_on:\n      - jaeger\n \n  jaeger:\n    image: jaegertracing/all-in-one:latest\n    container_name: jaeger\n    environment:\n      - COLLECTOR_OTLP_ENABLED=true\n      - COLLECTOR_OTLP_GRPC_HOST-PORT=:4317\n      - COLLECTOR_OTLP_GRPC_HOST_PORT=:4317\n    ports:\n      - &quot;16686:16686&quot;\n      # - &quot;4317:4317&quot;\n \notel-collector-config.yaml\nreceivers:\n  otlp:\n    protocols:\n      grpc:\n        endpoint: 0.0.0.0:4317\n \nprocessors:\n  batch:\n  attributes:\n    actions:\n      - key: solObjectID\n        value: &quot;7652&quot;\n        action: upsert\n      - key: imsSystemID\n        value: &quot;DataOps Data Virtualization&quot;\n        action: upsert\nexporters:\n  otlp:\n    endpoint: &quot;http://jaeger:4317&quot;\n    tls:\n      insecure: true\n  debug:\n    verbosity: detailed\n  prometheus:\n    endpoint: 0.0.0.0:8889\nservice:\n  pipelines:\n    traces:\n      receivers: [otlp]\n      processors: [attributes]\n      exporters: [otlp]\n    metrics:\n      receivers: [otlp]\n      processors: []\n      exporters: [prometheus]\n    logs:\n      receivers: [otlp]\n      processors: [batch]\n      exporters: [debug]\n \nУстарело\nЗапуск локального Jaeger для тестов:\ndocker run -p 16686:16686 -p 14250:14250 -p 4317:4317 -p 14268:14268 jaegertracing/all-in-one:latest\nили то же самое но с поддержкой OTLP протокола:\nversion: &quot;3.9&quot;\nservices:\n  jaeger:\n    image: &quot;jaegertracing/all-in-one:1.38&quot;\n    environment:\n      - COLLECTOR_OTLP_ENABLED=true\n    ports:\n      - 4317:4317\n      - 4318:4318\n      - 16686:16686"},"notes/Development/OTEL.-Golang":{"title":"OTEL. Golang","links":["notes/Development/OTEL.-Golang","notes/Development/Инициализация-OTEL-в-go","notes/Development/Автоматическое-инструментирование-http.Handler-OTEL","notes/Development/Проброс-span-через-HTTP-в-Opentelemetry","notes/Development/Проброс-span-Opentelemetry-через-текстовое-поле","notes/Development/OTEL-Baggage.-Golang","notes/Development/Базовая-настройка-OTEL-для-работы-с-Jaeger","notes/Development/Базовая-настройка-OTEL-для-работы-с-OTEL-Collector","notes/Development/Инструментирование-OTEL-MongoDB"],"tags":["reference/golang"],"content":"OTEL. Golang\n\nChildren:: Инициализация OTEL в go\nChildren:: Автоматическое инструментирование http.Handler OTEL\nChildren:: Проброс span через HTTP в Opentelemetry\nChildren:: Проброс span Opentelemetry через текстовое поле\nChildren:: OTEL Baggage. Golang\nChildren:: Базовая настройка OTEL для работы с Jaeger\nChildren:: Базовая настройка OTEL для работы с OTEL Collector\nChildren:: Инструментирование OTEL MongoDB\n"},"notes/Development/OpenTelemetry-Baggage":{"title":"OpenTelemetry Baggage","links":["notes/Development/OpenTelemetry-Baggage","notes/Development/OTEL-Baggage.-Golang"],"tags":[],"content":"OpenTelemetry Baggage\nЕсли возникает ситуация при которой вместо с trace’ом необходимо передать так же и некую метаинформацию Open Telemetry предлагает использовать механизм Baggage.\nПо сути baggage это способ передать key-value пары (возможно с некоторыми дополнительными свойствами) независимым от платформы способом. Точно так же как мы извлекаем информацию о span можно извлечь информацию о таких парах.\nChild:: OTEL Baggage. Golang\nSource:: opentelemetry.io/docs/concepts/signals/baggage/"},"notes/Development/OpenTelemetry-в-K8S":{"title":"OpenTelemetry в K8S","links":["notes/Development/OpenTelemetry-в-K8S","notes/Development/Инициализация-OTEL-в-go","notes/Development/Deployment"],"tags":["reference/kubernetes"],"content":"OpenTelemetry в K8S\nОписание\nOpenTelemetry Operator позволяет:\n\nСоздавать инстансы opentelemetrycollector в различных режимах.\nСоздавать шаблон sidecar контейнера который будет запущен в тех подах на которые повесим нужную аннотацию.\nСоздавать объекты instrumentation которые (при соответствующей аннотации) автоматически настроят код сервиса на работу с otel.\n\nУстановка\ncert-manager\nkubectl apply -f github.com/cert-manager/cert-manager/releases/download/v1.13.2/cert-manager.yaml\nOpenTelemetry Operator\nkubectl apply -f github.com/open-telemetry/opentelemetry-operator/releases/latest/download/opentelemetry-operator.yaml \nJaeger\nЭто лишь бэкенд для хранения метрик. Можно настроить любую другую систему\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: opentelemetry\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: jaeger-all-in-one\n  namespace: opentelemetry\n  labels:\n    app: opentelemetry\n    component: otel-collector\nspec:\n  ports:\n    - port: 4317\n      protocol: TCP\n      targetPort: grpc\n  selector:\n    component: otel-collector\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: jaeger-all-in-one-ui\n  namespace: opentelemetry\n  labels:\n    app: opentelemetry\n    component: otel-collector\nspec:\n  ports:\n    - name: jaeger\n      port: 16686\n      protocol: TCP\n      targetPort: 16686\n  selector:\n    component: otel-collector\n  type: LoadBalancer\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: jaeger-all-in-one\n  namespace: opentelemetry\n  labels:\n    app: opentelemetry\n    component: otel-collector\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: opentelemetry\n      component: otel-collector\n  template:\n    metadata:\n      labels:\n        app: opentelemetry\n        component: otel-collector\n    spec:\n      containers:\n        - image: jaegertracing/all-in-one:1.52\n          name: jaeger\n          ports:\n            - containerPort: 16686\n            - containerPort: 14268\n            - containerPort: 14250\n            - containerPort: 4317\n              name: grpc\nOtelcoll\nЭтот коллектор otel в текущем примере будет являться общим шлюзом получающим данные от sidecar контейнеров. Таким образом достаточно поменять лишь его настройки, а основную систему не трогать.\napiVersion: opentelemetry.io/v1alpha1\nkind: OpenTelemetryCollector\nmetadata:\n  name: otel-collector\n  namespace: opentelemetry\n  labels:\n    app: opentelemetry\n    component: otel-collector\nspec:\n  ports:\n    - port: 4318\n      name: &quot;grpc&quot;\n  config: |\n    receivers:\n      otlp:\n        protocols:\n          grpc:\n          http:\n    exporters:\n      otlp:\n        endpoint: jaeger-all-in-one.opentelemetry.svc.cluster.local:4317\n        tls:\n          insecure: true\n      logging:\n    processors:\n      batch:\n      resource:\n        attributes:\n          - key: test.key\n            value: &quot;test-value&quot;\n            action: insert\n    extensions:\n      health_check:\n      zpages:\n        endpoint: :55679\n    service:\n      telemetry:\n        logs:\n          level: &quot;debug&quot;\n      extensions: [zpages, health_check]\n      pipelines:\n        traces:\n          receivers: [otlp]\n          processors: [batch, resource]\n          exporters: [logging, otlp]\nSIdecar\nЭто в своём роде шаблон контейнера который будет запускаться внутри каждого пода имеющего соответствующую аннотацию.\napiVersion: opentelemetry.io/v1alpha1\nkind: OpenTelemetryCollector\nmetadata:\n  name: sidecar\nspec:\n  mode: sidecar\n  config: |\n    receivers:\n      otlp:\n        protocols:\n          grpc:\n          http:\n    processors:\n      batch:\n    exporters:\n      logging:\n      otlp:\n        endpoint: &quot;otel-collector-collector.opentelemetry.svc.cluster.local:4317&quot;\n        tls:\n          insecure: true\n    service:\n      telemetry:\n        logs:\n          level: &quot;debug&quot;\n      pipelines:\n        traces:\n          receivers: [otlp]\n          processors: []\n          exporters: [logging, otlp]\nInstrumentation\nРесурс k8s, что определяет настройки otel которые будут вставлены в запущенный сервис. Иными словами например Инициализация OTEL в go не требуется. Достаточно создать такой объект и повесить нужные аннотации.\napiVersion: opentelemetry.io/v1alpha1\nkind: Instrumentation\nmetadata:\n  name: demo-instrumentation\nspec:\n  propagators:\n    - tracecontext\n    - baggage\n  sampler:\n    type: parentbased_traceidratio\n    argument: &quot;1&quot;\nАннотации сервиса\n\nsidecar.opentelemetry.io/inject: &quot;sidecar&quot; - подключит в pod sidecar.\ninstrumentation.opentelemetry.io/inject-java: &quot;true&quot; - подключит код внутрь запущенного сервиса. На GolangS у меня не завелось\n\nDeployment целиком\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: rules-generator\n  labels:\n    app: rules-generator\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: rules-generator\n  template:\n    metadata:\n      labels:\n        app: rules-generator\n      annotations:\n        sidecar.opentelemetry.io/inject: &quot;sidecar&quot;\n        instrumentation.opentelemetry.io/inject-java: &quot;true&quot;\n    spec:\n      containers:\n        - name: rules-generator\n          image: maksim77/rules:0.0.1\n          ports:\n            - containerPort: 12346\n            - containerPort: 9999\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: rules-generator-service\n  labels:\n    app: rules-generator\nspec:\n  selector:\n    app: rules-generator\n  type: NodePort\n  ports:\n    - protocol: TCP\n      port: 9999\n      targetPort: 9999"},"notes/Development/OpenTelemetry":{"title":"OpenTelemetry","links":["notes/Development/OpenTelemetry","notes/Development/OTEL-and-Jaeger-local-dev","notes/Development/OTEL-initialization","notes/Development/OTEL.-Golang","notes/Development/OTEL.-Java","notes/Development/Структура-HTTP-Header-трэйсинга","notes/Development/OpenTelemetry-Baggage","notes/Development/OpenTelemetry-в-K8S","notes/Development/Observability-local-stand"],"tags":[],"content":"OpenTelemetry\n\n\nChildren:: OTEL&amp;Jaeger local dev\nChildren:: OTEL initialization\nChildren:: OTEL. Golang\nChildren:: OTEL. Java\nChildren:: Структура HTTP Header трэйсинга\nChildren:: OpenTelemetry Baggage\nChildren:: OpenTelemetry в K8S\nChildren:: Observability local stand\n\nFriend:: OpenTelemetry Registry"},"notes/Development/Thrift-Client.-Golang":{"title":"Thrift Client. Golang","links":["notes/Development/Thrift-Client.-Golang"],"tags":["reference/golang"],"content":"Thrift Client. Golang\nПример создания клиента для Thrift сервера.\nПоследняя строка это вызов метода.\nfunc main() {\n\ttransportFactory := thrift.NewTFramedTransportFactoryConf(thrift.NewTTransportFactory(), nil)\n\tprotocolFactoryBinary := thrift.NewTBinaryProtocolFactoryConf(nil)\n \n\t// protocolFactoryCompact := thrift.NewTCompactProtocolFactoryConf(nil)\n\tprotocolFactoryDebug := thrift.NewTDebugProtocolFactoryWithLogger(protocolFactoryBinary, &quot;&quot;, thrift.StdLogger(log.Default()))\n \n\ttransport := thrift.NewTSocketConf(net.JoinHostPort(HOST, PORT), nil)\n \n\tuseTransport, err := transportFactory.GetTransport(transport)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n \n\tclient := trino.NewTrinoThriftServiceClientFactory(useTransport, protocolFactoryDebug)\n\tif err := transport.Open(); err != nil {\n\t\tfmt.Fprintln(os.Stderr, &quot;Error opening socket to &quot;+HOST+&quot;:&quot;+PORT, &quot; &quot;, err)\n\t\tos.Exit(1)\n\t}\n\tdefer transport.Close()\n \n\tfmt.Println(client.TrinoListSchemaNames(context.Background()))\n}"},"notes/Development/Thrift-Client.-Java":{"title":"Thrift Client. Java","links":["notes/Development/Thrift-Client.-Java","notes/Development/Thrift-Client.-Golang"],"tags":[],"content":"Thrift Client. Java\npackage com.mts.dataops.virtualization;\n \nimport com.mts.dataops.datavirtualization.TrinoThriftService;\nimport org.apache.thrift.TException;\nimport org.apache.thrift.protocol.TBinaryProtocol;\nimport org.apache.thrift.protocol.TProtocol;\nimport org.apache.thrift.transport.TSocket;\nimport org.apache.thrift.transport.layered.TFramedTransport;\n \nimport java.util.List;\n \npublic class Client {\n    public void start() throws TException {\n        TSocket transport = new TSocket(&quot;localhost&quot;, 9998);\n        transport.open();\n        \n        TFramedTransport tFramedTransport = new TFramedTransport(transport);\n        TProtocol protocol = new TBinaryProtocol(tFramedTransport);\n        TrinoThriftService.Client client = new TrinoThriftService.Client(protocol);\n \n        List&lt;String&gt; schemas = client.trinoListSchemaNames();\n        System.out.println(schemas);\n    }\n}\n \nParent::\nChildren::\nFriend:: Thrift Client. Golang"},"notes/Development/Thrift-Codegen.-Golang":{"title":"Thrift Codegen. Golang","links":["notes/Development/Thrift-Codegen.-Golang","notes/Development/Thrift-Codegen.-Java"],"tags":[],"content":"Thrift Codegen. Golang\nthrift -r --gen go:skip_remote trino.thrift\nГде флаг skip_remote это:\n\nSkip the generating of -remote folders for the client binaries for services\n\nParent::\nChildren::\nFriend:: Thrift Codegen. Java"},"notes/Development/Thrift-Codegen.-Java":{"title":"Thrift Codegen. Java","links":["notes/Development/Thrift-Codegen.-Java"],"tags":[],"content":"Thrift Codegen. Java\nGradle\nplugins {\n    id &#039;java&#039;\n    id &quot;org.jruyi.thrift&quot; version &quot;0.4.2&quot;\n}\n \ngroup &#039;com.mts.dataops.virtualization&#039;\nversion &#039;1.0-SNAPSHOT&#039;\n \nrepositories {\n    mavenCentral()\n}\n \ndependencies {\n    implementation &#039;org.apache.thrift:libthrift:0.18.1&#039;\n    implementation &#039;javax.annotation:javax.annotation-api:1.3.2&#039;\n    implementation &#039;org.slf4j:slf4j-api:2.0.7&#039;\n    implementation &#039;org.slf4j:slf4j-simple:2.0.7&#039;\n \n    testImplementation &#039;org.junit.jupiter:junit-jupiter-api:5.8.1&#039;\n    testRuntimeOnly &#039;org.junit.jupiter:junit-jupiter-engine:5.8.1&#039;\n}\n \ntest {\n    useJUnitPlatform()\n}\n\nПодключить плагин org.jruyi.thrift.\nДобавить зависимости:\n\norg.apache.thrift:libthrift\njavax.annotation:javax.annotation-api\norg.slf4j:slf4j-api\n\n\nСпецификации thrift сложить в src/main/thrift\n\nТак же важно прописать в spec файле thrift’а namespace для Java:\nnamespace java com.mts.dataops.datavirtualization\n\nПосле этого в gradle станет доступна команда сборки исходников:\n./gradlew compileThrift"},"notes/Development/Thrift-Server.-Golang":{"title":"Thrift Server. Golang","links":["notes/Development/Thrift-Server.-Golang"],"tags":[],"content":"Thrift Server. Golang\nСоздание сервера\ntransportFactory := thrift.NewTFramedTransportFactoryConf(thrift.NewTTransportFactory(), nil)\nprotocolFactory := thrift.NewTBinaryProtocolFactoryConf(nil)\n\nDebug\nfunc main() {\n\tvar ts TrinoService\n \n\ttransportFactory := thrift.NewTFramedTransportFactoryConf(thrift.NewTTransportFactory(), nil)\n\tprotocolFactoryBinary := thrift.NewTBinaryProtocolFactoryConf(nil)\n \n\tprotocolFactoryDebug := thrift.NewTDebugProtocolFactoryWithLogger(protocolFactoryBinary, &quot;log&quot;, thrift.StdLogger(log.Default()))\n \n\ttransport, err := thrift.NewTServerSocket(&quot;:9998&quot;)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n \n\tprocessor := trino.NewTrinoThriftServiceProcessor(&amp;ts)\n\tserver := thrift.NewTSimpleServer4(processor, transport, transportFactory, protocolFactoryDebug)\n\tlog.Fatal(server.Serve())\n}\nКлиент"},"notes/Development/Thrift-Server.-Java":{"title":"Thrift Server. Java","links":["notes/Development/Thrift-Server.-Java"],"tags":[],"content":"Thrift Server. Java\npackage com.mts.dataops.virtualization;\n \nimport com.mts.dataops.datavirtualization.TrinoThriftService;\nimport org.apache.thrift.protocol.TBinaryProtocol;\nimport org.apache.thrift.server.TServer;\nimport org.apache.thrift.server.TThreadPoolServer;\nimport org.apache.thrift.transport.TServerSocket;\nimport org.apache.thrift.transport.TServerTransport;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.layered.TFramedTransport;\n \npublic class Main {\n    public static void main(String[] args) throws TTransportException {\n        Server trino = new Server();\n        TrinoThriftService.Processor&lt;Server&gt; processor = new TrinoThriftService.Processor&lt;&gt;(trino);\n \n        TServerTransport serverTransport = new TServerSocket(9998);\n        TFramedTransport.Factory transportFactory = new TFramedTransport.Factory();\n        TBinaryProtocol.Factory protocolFactory = new TBinaryProtocol.Factory();\n \n        TThreadPoolServer.Args thriftArgs = new TThreadPoolServer.Args(serverTransport)\n                .processor(processor).\n                inputProtocolFactory(protocolFactory).\n                inputTransportFactory(transportFactory).\n                outputTransportFactory(transportFactory);\n        TServer server = new TThreadPoolServer(thriftArgs);\n \n        Thread thread = new Thread(server::serve);\n        thread.start();\n    }\n}\n\n\n                  \n                  Debug \n                  \n                \n\nДля Java нет Debug реализации протоколов.\n\n"},"notes/Development/Thrift.-Golang":{"title":"Thrift. Golang","links":["notes/Development/Thrift.-Golang","notes/Development/Thrift-Server.-Golang","notes/Development/Thrift-Client.-Golang","notes/Development/Thrift-Codegen.-Golang"],"tags":[],"content":"Thrift. Golang\n\nChildren:: Thrift Server. Golang\nChildren:: Thrift Client. Golang\nChildren:: Thrift Codegen. Golang\n"},"notes/Development/Thrift.-Java":{"title":"Thrift. Java","links":["notes/Development/Thrift.-Java","notes/Development/Thrift-Client.-Java","notes/Development/Thrift-Codegen.-Java","notes/Development/Thrift-Server.-Java"],"tags":[],"content":"Thrift. Java\n\nChildren:: Thrift Client. Java\nChildren:: Thrift Codegen. Java\nChildren:: Thrift Server. Java\n"},"notes/Development/Thrift":{"title":"Thrift","links":["notes/Development/Thrift","notes/Development/Thrift.-Golang","notes/Development/Thrift.-Java","Trino-thrift-connector"],"tags":[],"content":"Thrift\n\nChildren:: Thrift. Golang\nChildren:: Thrift. Java\n\nРаботу с Thrift можно разделить на следующие слои:\n\nСервер\nПротокол\nТранспорт\n\nПротокол\n\nTBinaryProtocol — простой двоичный формат, кодирующий числовые значения как двоичные, а не преобразующий их в текст.\nTCompactProtocol — очень эффективное плотное кодирование данных (подробнее см. ниже).\nTDenseProtocol — похож на TCompactProtocol, но удаляет метаинформацию из передаваемых данных и добавляет её обратно на стороне получателя. TDenseProtocol всё ещё экспериментальный и пока недоступен в реализации на Java.\nTJSONProtocol — использует JSON для кодирования данных.\nTSimpleJSONProtocol — протокол только для записи с использованием JSON. Подходит для разбора скриптовыми языками.\nTDebugProtocol — использует читаемый человеком текстовый формат для помощи в отладке.\n\nТранспорт\n\nTSocket — использует блокирующий ввод-вывод через сокет для передачи данных.\nTFramedTransport — отправляет данные в кадрах, где каждый кадр предваряется указанием его длины. Этот транспорт необходим при использовании неблокирующего сервера.\nTFileTransport — этот транспорт осуществляет запись в файл. Хотя этот транспорт не входит в реализацию на Java, его должно быть достаточно просто реализовать.\nTMemoryTransport — для ввода-вывода использует память. Реализация на Java внутренне использует простой ByteArrayOutputStream.\nTZlibTransport — выполняет сжатие с помощью zlib. Используется вместе с другим транспортом. В реализации на Java недоступен.\n\nFriend:: Trino thrift connector"},"notes/Development/YandexGPT-в-Obsidian-TextGenerator":{"title":"YandexGPT в Obsidian TextGenerator","links":["notes/Development/YandexGPT-в-Obsidian-TextGenerator","notes/Development/Получение-IAM_TOKEN-в-YC","notes/Development/Получение-API-ключа-в-YC","notes/Development/Получение-ID-каталога-в-Yandex-Cloud","notes/Development/Температура-запроса-LLM","notes/Development/Роль-модели"],"tags":[],"content":"YandexGPT в Obsidian TextGenerator\nДля того чтобы работать с API YandexGPT необходимо быть зарегистрированным в Yandex Cloud и иметь действующий платежный аккаунт.\nДля авторизации в API потребуется либо IAM токен либо API ключ.\n\nПолучение IAM_TOKEN в YC\nПолучение API ключа в YC\n\nObsidian\n\nУстановить плагин TextGenerator\nВыбрать Provider Profile - Custom или клонировать его нажав +\n\nВ поле Endpoint указать llm.api.cloud.yandex.net/foundationModels/v1/completion\nВ поле API Key указать либо IAM_TOKEN либо API ключ полученный ранее\n\nAdvanced mode\nДальнейшие пункты настраиваются после включения переключателя Advanced mode.\n\nВ секции Headers указываем следующее при использовании ключа API.\n\n{\n    &quot;Content-Type&quot;: &quot;application/json&quot;,\n    &quot;Authorization&quot;: &quot;Api-Key {{api_key}}&quot;, \n    &quot;x-folder-id&quot;: &quot;b1gjpq05r3ppsou34c7d&quot;\n}\nИли вот так при при использовании IAM токена:\n{\n    &quot;Content-Type&quot;: &quot;application/json&quot;,\n    &quot;Authorization&quot;: &quot;Bearer {{api_key}}&quot;, \n    &quot;x-folder-id&quot;: &quot;b1gjpq05r3ppsou34c7d&quot;\n}\nВ x-folder-id необходимо подставить идентификатор того каталога для которого создавался ключ/токен.\n\nВ секции Body пропишем тело запроса.\n\n{\n  &quot;modelUri&quot;: &quot;gpt://b1gjpq05r3ppsou34c7d/yandexgpt/latest&quot;,\n  &quot;completionOptions&quot;: {\n    &quot;stream&quot;: false,\n    &quot;temperature&quot;: {{temperature}},\n    &quot;maxTokens&quot;: {{max_tokens}}\n  },\n  &quot;messages&quot;:  [{&quot;text&quot;:  {{stringify tg_selection}}, &quot;role&quot;:&quot;user&quot;}] \n}\nГде\n\nmodelUri это адрес модели выключающий в себя идентификатор каталога из шагов выше. Список существующих моделей можно посмотреть тут.\ntemperature - температура запроса.\nВ списке messages возможно стоит определить роль модели. Что-то типа:\n\n\nТы AI асистент встроенный в Obsidian. Твоё назначение помогать создавать и редактировать статьи внутри PKM.\n\n\nВ секции Response Sanatization прописываем обработчик ответов API:\n\nif (res.status &gt;= 300) {\n  const err = data?.error?.message || JSON.stringify(data);\n  throw err;\n}\n \nconst choices = data.result.alternatives.map(c =&gt; ({ content: c.message.text }));\n \nreturn choices;\n\nОбязательно устанавливаем галочку CORS Bypass\n\nЭкспортированный профиль\nTextGenerator поддерживает импорт-экспорт профилей. Ниже приведен сохраненный результат описывающий действия выше.\n{\n  id: &#039;Default (Custom) 2&#039;,\n  profile: {\n    extends: &#039;Default (Custom)&#039;,\n    name: &#039;YandexGPT&#039;,\n  },\n  config: {\n    endpoint: &#039;llm.api.cloud.yandex.net/foundationModels/v1/completion&#039;,\n    custom_header: &#039;{\\n    &quot;Content-Type&quot;: &quot;application/json&quot;,\\n    &quot;Authorization&quot;: &quot;Api-Key {{api_key}}&quot;, \\n&quot;x-folder-id&quot;: &quot;b1gjpq05r3ppsou34c7d&quot;\\n}&#039;,\n    custom_body: &#039;{\\n  &quot;modelUri&quot;: &quot;gpt://b1gjpq05r3ppsou34c7d/yandexgpt/latest&quot;,\\n  &quot;completionOptions&quot;: {\\n    &quot;stream&quot;: false,\\n    &quot;temperature&quot;: {{temperature}},\\n    &quot;maxTokens&quot;: {{max_tokens}}\\n  },\\n  &quot;messages&quot;:  [{&quot;text&quot;:  {{stringify tg_selection}}, &quot;role&quot;:&quot;user&quot;}] \\n}\\n&#039;,\n    model: &#039;gpt-3.5-turbo-16k&#039;,\n    sanatization_streaming: &#039;// catch error\\nif (res.status &gt;= 300) {\\n  const err = data?.error?.message || JSON.stringify(data);\\n  throw err;\\n}\\nlet resultText = &quot;&quot;;\\nconst lines = chunk.split(&quot;\\ndata: &quot;);\\n\\nconst parsedLines = lines\\n    .map((line) =&gt; line.replace(/^data: /, &quot;&quot;).trim()) // Remove the &quot;data: &quot; prefix\\n    .filter((line) =&gt; line !== &quot;&quot; &amp;&amp; line !== &quot;[DONE]&quot;) // Remove empty lines and &quot;[DONE]&quot;\\n    .map((line) =&gt; {\\n        try {\\n            return JSON.parse(line)\\n        } catch { }\\n    }) // Parse the JSON string\\n    .filter(Boolean);\\n\\nfor (const parsedLine of parsedLines) {\\n    const { choices } = parsedLine;\\n    const { delta } = choices[0];\\n    const { content } = delta;\\n    // Update the UI with the new content\\n    if (content) {\\n        resultText += content;\\n    }\\n}\\nreturn resultText;&#039;,\n    sanatization_response: &#039;if (res.status &gt;= 300) {\\n  const err = data?.error?.message || JSON.stringify(data);\\n  throw err;\\n}\\n\\nconst choices = data.result.alternatives.map(c =&gt; ({ content: c.message.text }));\\n\\nreturn choices;&#039;,\n    frequency_penalty: 0,\n    presence_penalty: 0.5,\n    top_p: 1,\n    CORSBypass: true,\n    streamable: false,\n    api_key: &#039;&#039;,\n  },\n}"},"notes/Development/Инициализация-OTEL-в-go":{"title":"Инициализация OTEL в go","links":["notes/Development/Инициализация-OTEL-в-go"],"tags":["reference/golang"],"content":"Инициализация OTEL в go\nКак можно раньше в коде следует выполнить блок инициализации телеметрии.\nБазовая инициализация\npackage main\n \nimport (\n        &quot;context&quot;\n        &quot;log&quot;\n        &quot;time&quot;\n \n        &quot;go.opentelemetry.io/otel&quot;\n        &quot;go.opentelemetry.io/otel/exporters/otlp/otlptrace&quot;\n        &quot;go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc&quot;\n        &quot;go.opentelemetry.io/otel/propagation&quot;\n        &quot;go.opentelemetry.io/otel/sdk/resource&quot;\n        sdktrace &quot;go.opentelemetry.io/otel/sdk/trace&quot;\n        semconv &quot;go.opentelemetry.io/otel/semconv/v1.4.0&quot;\n        &quot;google.golang.org/grpc&quot;\n)\n \nfunc initProvider() func() {\n        ctx := context.Background()\n        res, err := resource.New(ctx,\n                resource.WithFromEnv(),\n                resource.WithProcess(),\n                resource.WithTelemetrySDK(),\n                resource.WithHost(),\n                resource.WithAttributes(\n                        semconv.ServiceNameKey.String(&quot;demo-client&quot;),\n                ),\n        )\n        if err != nil {\n                log.Fatal(err)\n        }\n \n        traceClient := otlptracegrpc.NewClient(\n                otlptracegrpc.WithInsecure(),\n                otlptracegrpc.WithEndpoint(&quot;0.0.0.0:4317&quot;),\n                otlptracegrpc.WithDialOption(grpc.WithBlock()))\n        sctx, cancel := context.WithTimeout(ctx, time.Second)\n        defer cancel()\n \n        traceExp, err := otlptrace.New(sctx, traceClient)\n        if err != nil {\n                log.Fatal(err)\n        }\n \n        bsp := sdktrace.NewBatchSpanProcessor(traceExp)\n        tracerProvider := sdktrace.NewTracerProvider(\n                sdktrace.WithSampler(sdktrace.AlwaysSample()),\n                sdktrace.WithResource(res),\n                sdktrace.WithSpanProcessor(bsp),\n        )\n \n        // set global propagator to tracecontext (the default is no-op).\n        otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(propagation.TraceContext{}, propagation.Baggage{}))\n        otel.SetTracerProvider(tracerProvider)\n \n        return func() {\n                cxt, cancel := context.WithTimeout(ctx, time.Second)\n                defer cancel()\n                if err := traceExp.Shutdown(cxt); err != nil {\n                        otel.Handle(err)\n                }\n        }\n}\nИспользование в основном коде\nconst (\n        TRACER_NAME = &quot;demo_service&quot;\n)\n \nvar tracer = otel.Tracer(TRACER_NAME)\n \nfunc main() {\n        shutdown := initProvider()\n        defer shutdown()\nНу а далее от этого глобального tracer’а уже можно создавать спаны и\nжонглировать ими через контекст:\nnewCtx, span := tracer.Start(r.Context(), &quot;/&quot;)\ndefer span.End()"},"notes/Development/Компиляция-proto-файла-для-Golang":{"title":"Компиляция proto файла для Golang","links":["notes/Development/Компиляция-proto-файла-для-Golang"],"tags":["reference/golang"],"content":"Компиляция proto файла для Golang\nsyntax = &quot;proto3&quot;;\npackage ecommerce;\n \nservice ProductInfo {\n    rpc addProduct(Product) returns (ProductID);\n    rpc getProduct(ProductID) returns(Product);\n};\n \nmessage Product {\n    string id = 1;\n    string name = 2;\n    string description = 3;\n};\n \nmessage ProductID {\n    string value = 1;\n};\nprotoc --go-grpc_out=. --go-grpc_opt=Mecommerce/product_info.proto=./ecommerce --go_out=. --go_opt=Mecommerce/product_info.proto=./ecommerce  ecommerce/product_info.proto\nАльтернативой указания значений Mecommerce/product_info.proto=./ecommerce может стать определение значений go_package в proto:\noption go_package = &quot;./;investapi&quot;;\n"},"notes/Development/Подключение-к-GRPC-server'у":{"title":"Подключение к GRPC server'у","links":["notes/Development/Подключение-к-GRPC-server'у"],"tags":["reference/golang"],"content":"Подключение к GRPC server’у\nSimple server\nСоздание сервера\ntype server struct {\n\tproductMap map[string]*pb.Product\n\tecommerce.UnimplementedProductInfoServer\n}\n \nconst (\n\tport = &quot;:50051&quot;\n)\n \nfunc main() {\n\tlis, err := net.Listen(&quot;tcp&quot;, port)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\ts := grpc.NewServer()\n\tecommerce.RegisterProductInfoServer(s, &amp;server{})\n\tlog.Printf(&quot;Starting gRPC listener on port %s&quot;, port)\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(&quot;failed serve: %v&quot;, err)\n\t}\n}\nСоздание клиента\npackage main\n \nimport (\n\t&quot;context&quot;\n\t&quot;log&quot;\n\t&quot;time&quot;\n \n\t&quot;client/ecommerce&quot;\n \n\t&quot;google.golang.org/grpc&quot;\n\t&quot;google.golang.org/grpc/credentials/insecure&quot;\n)\n \nconst (\n\taddress = &quot;localhost:50051&quot;\n)\n \nfunc main() {\n\tconn, err := grpc.Dial(address, grpc.WithTransportCredentials(insecure.NewCredentials()))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer conn.Close()\n \n\tc := ecommerce.NewProductInfoClient(conn)\n\tname := &quot;Apple iPhone 11&quot;\n\tdescription := &quot;Some phone&quot;\n \n\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\tdefer cancel()\n\tr, err := c.AddProduct(ctx, &amp;ecommerce.Product{Name: name, Description: description})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tlog.Printf(&quot;Product ID: %s added successfully&quot;, r.Value)\n \n\tproduct, err := c.GetProduct(ctx, &amp;ecommerce.ProductID{Value: r.Value})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tlog.Printf(&quot;Product: %s&quot;, product.String())\n}\nTinkoff OpenAPI\nconn, err := grpc.Dial(&quot;invest-public-api.tinkoff.ru:443&quot;,\n\tgrpc.WithTransportCredentials(credentials.NewTLS(&amp;tls.Config{})),\n\tgrpc.WithPerRPCCredentials(oauth.TokenSource{\n\t\tTokenSource: oauth2.StaticTokenSource(&amp;oauth2.Token{\n\t\t\tAccessToken: &quot;token&quot;,\n\t\t\t}),\n\t\t}))\n\tif err != nil {\n\t\tlog.Fatalf(&quot;did not connect: %v&quot;, err)\n\t}\n\tdefer conn.Close()\nПосле чего объект conn можно передавать в функции создание новых сервисов."},"notes/Development/Получение-API-ключа-в-YC":{"title":"Получение API ключа в YC","links":["notes/Development/Получение-API-ключа-в-YC","notes/Development/Получение-списка-Service-Account-в-YC"],"tags":[],"content":"Получение API ключа в YC\nЭто инструкция по созданию API-ключа для сервисного аккаунта. API-ключ — секретный ключ, используемый для упрощенной авторизации в API Yandex Cloud.\nЕсли у вас еще нет сервисного аккаунта, создайте его и назначьте ему роли.\nЧтобы создать API-ключ:\n\nСоздайте API-ключ с помощью метода REST API create для ресурса ApiKey:\n\nexport SERVICEACCOUNT_ID=&lt;идентификатор_сервисного_аккаунта&gt;\nexport IAM_TOKEN=&lt;токен&gt;\ncurl -X POST \\\n  -H &quot;Content-Type: application/json&quot; \\\n  -H &quot;Authorization: Bearer $IAM_TOKEN&quot; \\\n  -d &quot;{\n      \\&quot;serviceAccountId\\&quot;: \\&quot;$SERVICEACCOUNT_ID\\&quot;,\n      \\&quot;scope\\&quot;: \\&quot;&lt;область_действия&gt;\\&quot;,\n      \\&quot;expiresAt\\&quot;: \\&quot;&lt;дата_и_время&gt;\\&quot;\n  }&quot; \\\n  iam.api.cloud.yandex.net/iam/v1/apiKeys\nГде:\n\nSERVICEACCOUNT_ID — идентификатор сервисного аккаунта. Обязательный параметр.\nIAM_TOKEN — IAM-токен. Обязательный параметр.\nscope — область действия для ключа с ограниченным доступом. Необязательный параметр.\nexpiresAt — дата и время истечения срока действия ключа с ограниченным доступом. Необязательный параметр.\n"},"notes/Development/Получение-IAM_TOKEN-в-YC":{"title":"Получение IAM_TOKEN в YC","links":["notes/Development/Получение-IAM_TOKEN-в-YC"],"tags":[],"content":"Получение IAM_TOKEN в YC\n\nВойдите- в ваш аккаунт на Яндексе.\nПолучите OAuth-токен в сервисе Яндекс.OAuth. Для этого перейдите по ссылке, нажмите Разрешить и скопируйте полученный OAuth-токен.\nОбменяйте OAuth-токен на IAM-токен:\n\ncurl -X POST \\\n  -d &#039;{&quot;yandexPassportOauthToken&quot;:&quot;&lt;OAuth-токен&gt;&quot;}&#039; \\\n  iam.api.cloud.yandex.net/iam/v1/tokens"},"notes/Development/Получение-ID-каталога-в-Yandex-Cloud":{"title":"Получение ID каталога в Yandex Cloud","links":["notes/Development/Получение-ID-каталога-в-Yandex-Cloud","notes/Development/Получение-ID-облака-в-Yandex-Cloud"],"tags":[],"content":"Получение ID каталога в Yandex Cloud\nДля использования многих методов API YC требуется знать идентификатор каталога в облаке.\nПолучение id облака\nИдентификатор самого облака в свою очередь можно получить вот так:\nTransclude of Получение-ID-облака-в-Yandex-Cloud\nПолучение id каталога(в)\nhttp GET resource-manager.api.cloud.yandex.net/resource-manager/v1/folders Authorization:&quot;Bearer $IAM_TOKEN&quot; cloud_id=b1gp230h62h8oavhctri\nОтвет:\n{\n    &quot;folders&quot;: [\n        {\n            &quot;cloudId&quot;: &quot;b1gp230h62h8oavhctri&quot;,\n            &quot;createdAt&quot;: &quot;2020-09-19T07:20:09Z&quot;,\n            &quot;id&quot;: &quot;b1gjpq05r3ppsou34c7d&quot;,\n            &quot;name&quot;: &quot;default&quot;,\n            &quot;status&quot;: &quot;ACTIVE&quot;\n        }\n    ]\n}"},"notes/Development/Получение-ID-облака-в-Yandex-Cloud":{"title":"Получение ID облака в Yandex Cloud","links":["notes/Development/Получение-ID-облака-в-Yandex-Cloud","notes/Development/Получение-IAM_TOKEN-в-YC"],"tags":[],"content":"Получение ID облака в Yandex Cloud\nДля того чтобы узнать id облаков доступных в YC необходимо выполнить следующий запрос (необходим I AM токен):\nhttp GET resource-manager.api.cloud.yandex.net/resource-manager/v1/clouds  Authorization:&quot;Bearer $IAM_TOKEN&quot;\nОтвет:\n{\n    &quot;clouds&quot;: [\n        {\n            &quot;createdAt&quot;: &quot;2020-09-19T07:20:09Z&quot;,\n            &quot;id&quot;: &quot;b1gp230h62h8oavhctri&quot;,\n            &quot;name&quot;: &quot;maksim77&quot;,\n            &quot;organizationId&quot;: &quot;bpfulqitoarhlo1a29ln&quot;\n        }\n    ]\n}"},"notes/Development/Получение-списка-Service-Account-в-YC":{"title":"Получение списка Service Account в YC","links":["notes/Development/Получение-списка-Service-Account-в-YC","notes/Development/Получение-IAM_TOKEN-в-YC"],"tags":[],"content":"Получение списка Service Account в YC\nНеобходимо получить IAM_TOKEN и знать идентификатор каталога (FOLDER_ID).\nexport FOLDER_ID=b1gvmob95yys********\nexport IAM_TOKEN=CggaATEVAgA...\ncurl -H &quot;Authorization: Bearer ${IAM_TOKEN}&quot; \\\n  &quot;iam.api.cloud.yandex.net/iam/v1/serviceAccounts${FOLDER_ID}&quot;\n \n{\n &quot;serviceAccounts&quot;: [\n  {\n   &quot;id&quot;: &quot;ajebqtreob2d********&quot;,\n   &quot;folderId&quot;: &quot;b1gvmob95yys********&quot;,\n   &quot;createdAt&quot;: &quot;2018-10-18T13:42:40Z&quot;,\n   &quot;name&quot;: &quot;my-robot&quot;,\n   &quot;description&quot;: &quot;my description&quot;\n  }\n ]\n}"},"notes/Development/Проброс-span-через-HTTP-в-Opentelemetry":{"title":"Проброс span через HTTP в Opentelemetry","links":["notes/Development/Проброс-span-через-HTTP-в-Opentelemetry","notes/Development/OpenTelemetry"],"tags":["reference/golang"],"content":"Проброс span через HTTP в Opentelemetry\nДля того чтобы пробросить span OpenTelemetry, а точнее конечно же его ID через http запрос можно использовать следующую схему.\n\nПри начальной настройке объекта otel необходимо указать:\n\notel.SetTextMapPropagator(propagation.TraceContext{})\n\nДалее существующий контекст который содержит span необходимо завернуть в Header запроса который мы будем выполнять:\n\notel.GetTextMapPropagator().Inject(newCtx, propagation.HeaderCarrier(req.Header))\nГде newCtx это контекст который вернулся при создании исходного span.\n\nНа стороне обработчика запроса принимающей стороны необходимо распаковать контекст из пришедшего request header.\n\nctx := otel.GetTextMapPropagator().Extract(r.Context(), propagation.HeaderCarrier(r.Header))\n_, span := tracer.Start(ctx, &quot;remoteservice&quot;)\ndefer span.End()"},"notes/Development/Роль-модели":{"title":"Роль модели","links":["notes/Development/Роль-модели"],"tags":[],"content":"Роль модели\nПри использовании API для общения с языковыми моделями можно задавать роль модели. Это позволяет адаптировать её поведение под конкретные задачи или сценарии. Роль системы (system role) задаёт инструкции, которые влияют на последующее взаимодействие.\nОсновные роли\n\nsystem — определяет поведение модели и задаёт её стиль.\nuser — сообщение от пользователя с запросом или задачей.\nassistant — ответы от модели на запросы.\n\nПример использования API с указанием роли системы\n{\n  &quot;model&quot;: &quot;advanced-llm&quot;,\n  &quot;messages&quot;: [\n    {&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;You are a helpful assistant that specializes in product management and databases.&quot;},\n    {&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;What are the key benefits of using the latest database version for large-scale applications?&quot;}\n  ]\n}"},"notes/Development/Создание-перехватчика-GRPC":{"title":"Создание перехватчика GRPC","links":["notes/Development/Создание-перехватчика-GRPC","notes/Development/OpenTelemetry"],"tags":["reference/golang"],"content":"Создание перехватчика GRPC\nМожет быть полезно для OpenTelemetry.\nServer Unary Intercepter\nfunc MyInter(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {\n\tfmt.Println(ctx)\n\tfmt.Println(info.FullMethod)\n\treturn handler(ctx, req)\n}\n \nfunc main() {\n\tlis, err := net.Listen(&quot;tcp&quot;, port)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\ts := grpc.NewServer(grpc.UnaryInterceptor(MyInter))\n\tecommerce.RegisterProductInfoServer(s, &amp;server{})\n\tlog.Printf(&quot;Starting gRPC listener on port %s&quot;, port)\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(&quot;failed serve: %v&quot;, err)\n\t}\n}"},"notes/Development/Структура-HTTP-Header-трэйсинга":{"title":"Структура HTTP Header трэйсинга","links":[],"tags":[],"content":"Trace Context\nЗаголовок HTTP отвечающий за передачу идентификатора span’а это traceparent.\nПример его содержимого:\ntraceparent: 00-0af7651916cd43dd8448eb211c80319c-b9c7c989f97918e1-01\n\nГде через дефис разделены следующие компоненты:\n\nversion - в настоящий момент всегда 00.\ntrace-id - основной идентификатор трэйса. Следует использовать именно его для поиска в системах типа Jaeger или Zipkin.\nparent-id - Идентификатор родительского Span’а.\ntrace-flags - служебные флаги\n\nSource:: www.w3.org/TR/trace-context/"},"notes/Development/Температура-запроса-LLM":{"title":"Температура запроса LLM","links":["notes/Development/Температура-запроса-LLM"],"tags":[],"content":"Температура запроса LLM\nОписание:\nПараметр temperature (температура) используется в моделях генерации текста, таких как LLM (Large Language Models), для управления степенью случайности в процессе генерации.\nФункция:\n\nНизкие значения temperature (например, 0.1) приводят к более детерминированным и предсказуемым результатам, где модель выбирает наиболее вероятные слова.\nВысокие значения temperature (например, 1.0 и выше) увеличивают разнообразие и креативность генерируемого текста, позволяя модели делать более рискованные и неожиданные выборы.\n\nПрименение:\n\nНастройка temperature позволяет пользователям контролировать баланс между креативностью и предсказуемостью в сгенерированном контенте, в зависимости от конкретных задач и целей.\n"},"notes/Development/Установка-GRPC-в-Golang":{"title":"Установка GRPC в Golang","links":["notes/Development/Установка-GRPC-в-Golang"],"tags":["reference/golang"],"content":"Установка GRPC в Golang\nLinux\n$ apt install -y protobuf-compiler\n$ protoc --version  # Ensure compiler version is 3+\nMac OS\n$ brew install protobuf\n$ protoc --version  # Ensure compiler version is 3+\nGolang\n$ go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28\n$ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2"}}